// @generated by protobuf-ts 2.11.1 with parameter long_type_bigint
// @generated from protobuf file "mediacorral/analysis/v1/main.proto" (package "mediacorral.analysis.v1", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message mediacorral.analysis.v1.AnalyzeMkvRequest
 */
export interface AnalyzeMkvRequest {
    /**
     * The blob ID of the file to analyze
     *
     * @generated from protobuf field: string blob_id = 1
     */
    blobId: string;
    /**
     * Overrides the subtitle track selection algorithm.
     * A value of `0` means "use default heuristics".
     *
     * @generated from protobuf field: uint64 st_track_number = 2
     */
    stTrackNumber: bigint;
}
/**
 * @generated from protobuf message mediacorral.analysis.v1.AnalyzeMkvResponse
 */
export interface AnalyzeMkvResponse {
    /**
     * Includes overall metadata about the content
     *
     * @generated from protobuf field: mediacorral.analysis.v1.MediaDetails media_details = 1
     */
    mediaDetails?: MediaDetails;
    /**
     * Includes a full subtitle track in SRT format. This will eventually go away
     * in favor of a streaming solution.
     *
     * @generated from protobuf field: optional mediacorral.analysis.v1.AggregatedSubtitles aggregated_subtitles = 2
     */
    aggregatedSubtitles?: AggregatedSubtitles;
}
/**
 * Subtitles that are transferred as one large unit.
 *
 * This likely will not stick around. I want to start streaming subtitles
 * in frames, and allow graphic-to-graphic conversion instead of just OCR.
 *
 * I also want to be able to transcode subtitles on-demand, so if the
 * automatic track selection chose a non-ideal track, the user can try a
 * different one.
 *
 * @generated from protobuf message mediacorral.analysis.v1.AggregatedSubtitles
 */
export interface AggregatedSubtitles {
    /**
     * The actual text-based subtitles
     *
     * @generated from protobuf field: string subtitles = 1
     */
    subtitles: string;
    /**
     * The track number from which these subtitles came. This will match a track
     * number from a corresponding `MediaDetails.subtitle_tracks[].track_number`
     * entry
     *
     * @generated from protobuf field: uint64 track_number = 2
     */
    trackNumber: bigint;
}
/**
 * Metadata found in the media file. This contains small bits of data that
 * may be cached in other formats, or stored as a blob. This is comprised mostly
 * of format-shifted MKV metadata, but in protobuf format for easier consumption
 * by other services.
 *
 * @generated from protobuf message mediacorral.analysis.v1.MediaDetails
 */
export interface MediaDetails {
    /**
     * @generated from protobuf field: uint32 duration = 1
     */
    duration: number;
    /**
     * @generated from protobuf field: repeated mediacorral.analysis.v1.ChapterInfo chapter_info = 2
     */
    chapterInfo: ChapterInfo[];
    /**
     * @generated from protobuf field: repeated mediacorral.analysis.v1.VideoTrack video_tracks = 3
     */
    videoTracks: VideoTrack[];
    /**
     * @generated from protobuf field: repeated mediacorral.analysis.v1.AudioTrack audio_tracks = 4
     */
    audioTracks: AudioTrack[];
    /**
     * @generated from protobuf field: repeated mediacorral.analysis.v1.SubtitleTrack subtitle_tracks = 5
     */
    subtitleTracks: SubtitleTrack[];
    /**
     * @generated from protobuf field: string name = 6
     */
    name: string;
}
/**
 * Information about a chapter within a media file
 *
 * @generated from protobuf message mediacorral.analysis.v1.ChapterInfo
 */
export interface ChapterInfo {
    /**
     * @generated from protobuf field: uint32 chapter_number = 1
     */
    chapterNumber: number;
    /**
     * @generated from protobuf field: uint64 chapter_uid = 2
     */
    chapterUid: bigint;
    /**
     * @generated from protobuf field: uint64 chapter_start_ns = 3
     */
    chapterStartNs: bigint;
    /**
     * @generated from protobuf field: uint64 chapter_end_ns = 4
     */
    chapterEndNs: bigint;
    /**
     * @generated from protobuf field: string chapter_name = 5
     */
    chapterName: string;
}
/**
 * Information about a video track within a media file
 *
 * @generated from protobuf message mediacorral.analysis.v1.VideoTrack
 */
export interface VideoTrack {
    /**
     * @generated from protobuf field: uint64 track_number = 1
     */
    trackNumber: bigint;
    /**
     * @generated from protobuf field: uint64 track_uid = 2
     */
    trackUid: bigint;
    /**
     * @generated from protobuf field: bytes hash = 3
     */
    hash: Uint8Array;
    /**
     * @generated from protobuf field: bool enabled = 4
     */
    enabled: boolean;
    /**
     * @generated from protobuf field: bool default = 5
     */
    default: boolean;
    /**
     * @generated from protobuf field: bool commentary = 6
     */
    commentary: boolean;
    /**
     * @generated from protobuf field: bool original = 7
     */
    original: boolean;
    /**
     * @generated from protobuf field: bool visual_impaired = 8
     */
    visualImpaired: boolean;
    /**
     * @generated from protobuf field: optional string name = 9
     */
    name?: string;
    /**
     * @generated from protobuf field: optional string language = 10
     */
    language?: string;
    /**
     * @generated from protobuf field: string codec_id = 11
     */
    codecId: string;
    /**
     * @generated from protobuf field: mediacorral.analysis.v1.VideoStereoMode stereo_mode = 12
     */
    stereoMode: VideoStereoMode;
    /**
     * @generated from protobuf field: uint64 display_width = 13
     */
    displayWidth: bigint;
    /**
     * @generated from protobuf field: uint64 display_height = 14
     */
    displayHeight: bigint;
}
/**
 * Information about an audio track within a media file
 *
 * @generated from protobuf message mediacorral.analysis.v1.AudioTrack
 */
export interface AudioTrack {
    /**
     * @generated from protobuf field: uint64 track_number = 1
     */
    trackNumber: bigint;
    /**
     * @generated from protobuf field: uint64 track_uid = 2
     */
    trackUid: bigint;
    /**
     * @generated from protobuf field: bytes hash = 3
     */
    hash: Uint8Array;
    /**
     * @generated from protobuf field: bool enabled = 4
     */
    enabled: boolean;
    /**
     * @generated from protobuf field: bool default = 5
     */
    default: boolean;
    /**
     * @generated from protobuf field: bool commentary = 6
     */
    commentary: boolean;
    /**
     * @generated from protobuf field: bool original = 7
     */
    original: boolean;
    /**
     * @generated from protobuf field: bool visual_impaired = 8
     */
    visualImpaired: boolean;
    /**
     * @generated from protobuf field: optional string name = 9
     */
    name?: string;
    /**
     * @generated from protobuf field: optional string language = 10
     */
    language?: string;
    /**
     * @generated from protobuf field: string codec_id = 11
     */
    codecId: string;
    /**
     * @generated from protobuf field: uint64 channels = 12
     */
    channels: bigint;
}
/**
 * Information about a subtitle track within a media file
 *
 * @generated from protobuf message mediacorral.analysis.v1.SubtitleTrack
 */
export interface SubtitleTrack {
    /**
     * @generated from protobuf field: uint64 track_number = 1
     */
    trackNumber: bigint;
    /**
     * @generated from protobuf field: uint64 track_uid = 2
     */
    trackUid: bigint;
    /**
     * @generated from protobuf field: bytes hash = 3
     */
    hash: Uint8Array;
    /**
     * @generated from protobuf field: bool enabled = 4
     */
    enabled: boolean;
    /**
     * @generated from protobuf field: bool default = 5
     */
    default: boolean;
    /**
     * @generated from protobuf field: bool commentary = 6
     */
    commentary: boolean;
    /**
     * @generated from protobuf field: bool original = 7
     */
    original: boolean;
    /**
     * @generated from protobuf field: bool visual_impaired = 8
     */
    visualImpaired: boolean;
    /**
     * @generated from protobuf field: optional string name = 9
     */
    name?: string;
    /**
     * @generated from protobuf field: optional string language = 10
     */
    language?: string;
    /**
     * @generated from protobuf field: string codec_id = 11
     */
    codecId: string;
}
/**
 * The type of stereoscopy (if any) used within a video track.
 *
 * For 2D video, this will always be "mono". For 3D, this indicates
 * the type of stereoscopy used.
 *
 * @generated from protobuf enum mediacorral.analysis.v1.VideoStereoMode
 */
export enum VideoStereoMode {
    /**
     * Unknown.
     *
     * @generated from protobuf enum value: VIDEO_STEREO_MODE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Mono.
     *
     * @generated from protobuf enum value: VIDEO_STEREO_MODE_MONO = 1;
     */
    MONO = 1,
    /**
     * Side by side (left eye first).
     *
     * @generated from protobuf enum value: VIDEO_STEREO_MODE_SIDE_BY_SIDE_LEFT_EYE_FIRST = 2;
     */
    SIDE_BY_SIDE_LEFT_EYE_FIRST = 2,
    /**
     * Top - bottom (right eye is first).
     *
     * @generated from protobuf enum value: VIDEO_STEREO_MODE_TOP_BOTTOM_RIGHT_EYE_FIRST = 3;
     */
    TOP_BOTTOM_RIGHT_EYE_FIRST = 3,
    /**
     * Top - bottom (left eye is first).
     *
     * @generated from protobuf enum value: VIDEO_STEREO_MODE_TOP_BOTTOM_LEFT_EYE_FIRST = 4;
     */
    TOP_BOTTOM_LEFT_EYE_FIRST = 4,
    /**
     * Checkboard (right eye is first).
     *
     * @generated from protobuf enum value: VIDEO_STEREO_MODE_CHECKBOARD_RIGHT_EYE_FIRST = 5;
     */
    CHECKBOARD_RIGHT_EYE_FIRST = 5,
    /**
     * Checkboard (left eye is first).
     *
     * @generated from protobuf enum value: VIDEO_STEREO_MODE_CHECKBOARD_LEFT_EYE_FIRST = 6;
     */
    CHECKBOARD_LEFT_EYE_FIRST = 6,
    /**
     * Row interleaved (right eye is first).
     *
     * @generated from protobuf enum value: VIDEO_STEREO_MODE_ROW_INTERLEAVED_RIGHT_EYE_FIRST = 7;
     */
    ROW_INTERLEAVED_RIGHT_EYE_FIRST = 7,
    /**
     * Row interleaved (left eye is first).
     *
     * @generated from protobuf enum value: VIDEO_STEREO_MODE_ROW_INTERLEAVED_LEFT_EYE_FIRST = 8;
     */
    ROW_INTERLEAVED_LEFT_EYE_FIRST = 8,
    /**
     * Column interleaved (right eye is first).
     *
     * @generated from protobuf enum value: VIDEO_STEREO_MODE_COLUMN_INTERLEAVED_RIGHT_EYE_FIRST = 9;
     */
    COLUMN_INTERLEAVED_RIGHT_EYE_FIRST = 9,
    /**
     * Column interleaved (left eye is first).
     *
     * @generated from protobuf enum value: VIDEO_STEREO_MODE_COLUMN_INTERLEAVED_LEFT_EYE_FIRST = 10;
     */
    COLUMN_INTERLEAVED_LEFT_EYE_FIRST = 10,
    /**
     * Anaglyph (cyan/red).
     *
     * @generated from protobuf enum value: VIDEO_STEREO_MODE_ANAGLYPH_CYAN_RED = 11;
     */
    ANAGLYPH_CYAN_RED = 11,
    /**
     * Side by side (right eye first).
     *
     * @generated from protobuf enum value: VIDEO_STEREO_MODE_SIDE_BY_SIDE_RIGHT_EYE_FIRST = 12;
     */
    SIDE_BY_SIDE_RIGHT_EYE_FIRST = 12,
    /**
     * Anaglyph (green/magenta).
     *
     * @generated from protobuf enum value: VIDEO_STEREO_MODE_ANAGLYPH_GREEN_MAGENTA = 13;
     */
    ANAGLYPH_GREEN_MAGENTA = 13,
    /**
     * Both eyes laced in one Block (left eye is first).
     *
     * @generated from protobuf enum value: VIDEO_STEREO_MODE_LACED_LEFT_EYE_FIRST = 14;
     */
    LACED_LEFT_EYE_FIRST = 14,
    /**
     * Both eyes laced in one Block (right eye is first).
     *
     * @generated from protobuf enum value: VIDEO_STEREO_MODE_LACED_RIGHT_EYE_FIRST = 15;
     */
    LACED_RIGHT_EYE_FIRST = 15
}
// @generated message type with reflection information, may provide speed optimized methods
class AnalyzeMkvRequest$Type extends MessageType<AnalyzeMkvRequest> {
    constructor() {
        super("mediacorral.analysis.v1.AnalyzeMkvRequest", [
            { no: 1, name: "blob_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "st_track_number", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<AnalyzeMkvRequest>): AnalyzeMkvRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.blobId = "";
        message.stTrackNumber = 0n;
        if (value !== undefined)
            reflectionMergePartial<AnalyzeMkvRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AnalyzeMkvRequest): AnalyzeMkvRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string blob_id */ 1:
                    message.blobId = reader.string();
                    break;
                case /* uint64 st_track_number */ 2:
                    message.stTrackNumber = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AnalyzeMkvRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string blob_id = 1; */
        if (message.blobId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.blobId);
        /* uint64 st_track_number = 2; */
        if (message.stTrackNumber !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.stTrackNumber);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mediacorral.analysis.v1.AnalyzeMkvRequest
 */
export const AnalyzeMkvRequest = new AnalyzeMkvRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AnalyzeMkvResponse$Type extends MessageType<AnalyzeMkvResponse> {
    constructor() {
        super("mediacorral.analysis.v1.AnalyzeMkvResponse", [
            { no: 1, name: "media_details", kind: "message", T: () => MediaDetails },
            { no: 2, name: "aggregated_subtitles", kind: "message", T: () => AggregatedSubtitles }
        ]);
    }
    create(value?: PartialMessage<AnalyzeMkvResponse>): AnalyzeMkvResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<AnalyzeMkvResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AnalyzeMkvResponse): AnalyzeMkvResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mediacorral.analysis.v1.MediaDetails media_details */ 1:
                    message.mediaDetails = MediaDetails.internalBinaryRead(reader, reader.uint32(), options, message.mediaDetails);
                    break;
                case /* optional mediacorral.analysis.v1.AggregatedSubtitles aggregated_subtitles */ 2:
                    message.aggregatedSubtitles = AggregatedSubtitles.internalBinaryRead(reader, reader.uint32(), options, message.aggregatedSubtitles);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AnalyzeMkvResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mediacorral.analysis.v1.MediaDetails media_details = 1; */
        if (message.mediaDetails)
            MediaDetails.internalBinaryWrite(message.mediaDetails, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional mediacorral.analysis.v1.AggregatedSubtitles aggregated_subtitles = 2; */
        if (message.aggregatedSubtitles)
            AggregatedSubtitles.internalBinaryWrite(message.aggregatedSubtitles, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mediacorral.analysis.v1.AnalyzeMkvResponse
 */
export const AnalyzeMkvResponse = new AnalyzeMkvResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AggregatedSubtitles$Type extends MessageType<AggregatedSubtitles> {
    constructor() {
        super("mediacorral.analysis.v1.AggregatedSubtitles", [
            { no: 1, name: "subtitles", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "track_number", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<AggregatedSubtitles>): AggregatedSubtitles {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subtitles = "";
        message.trackNumber = 0n;
        if (value !== undefined)
            reflectionMergePartial<AggregatedSubtitles>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AggregatedSubtitles): AggregatedSubtitles {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string subtitles */ 1:
                    message.subtitles = reader.string();
                    break;
                case /* uint64 track_number */ 2:
                    message.trackNumber = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AggregatedSubtitles, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string subtitles = 1; */
        if (message.subtitles !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.subtitles);
        /* uint64 track_number = 2; */
        if (message.trackNumber !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.trackNumber);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mediacorral.analysis.v1.AggregatedSubtitles
 */
export const AggregatedSubtitles = new AggregatedSubtitles$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MediaDetails$Type extends MessageType<MediaDetails> {
    constructor() {
        super("mediacorral.analysis.v1.MediaDetails", [
            { no: 1, name: "duration", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "chapter_info", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ChapterInfo },
            { no: 3, name: "video_tracks", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => VideoTrack },
            { no: 4, name: "audio_tracks", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => AudioTrack },
            { no: 5, name: "subtitle_tracks", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SubtitleTrack },
            { no: 6, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MediaDetails>): MediaDetails {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.duration = 0;
        message.chapterInfo = [];
        message.videoTracks = [];
        message.audioTracks = [];
        message.subtitleTracks = [];
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<MediaDetails>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MediaDetails): MediaDetails {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 duration */ 1:
                    message.duration = reader.uint32();
                    break;
                case /* repeated mediacorral.analysis.v1.ChapterInfo chapter_info */ 2:
                    message.chapterInfo.push(ChapterInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated mediacorral.analysis.v1.VideoTrack video_tracks */ 3:
                    message.videoTracks.push(VideoTrack.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated mediacorral.analysis.v1.AudioTrack audio_tracks */ 4:
                    message.audioTracks.push(AudioTrack.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated mediacorral.analysis.v1.SubtitleTrack subtitle_tracks */ 5:
                    message.subtitleTracks.push(SubtitleTrack.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string name */ 6:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MediaDetails, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 duration = 1; */
        if (message.duration !== 0)
            writer.tag(1, WireType.Varint).uint32(message.duration);
        /* repeated mediacorral.analysis.v1.ChapterInfo chapter_info = 2; */
        for (let i = 0; i < message.chapterInfo.length; i++)
            ChapterInfo.internalBinaryWrite(message.chapterInfo[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated mediacorral.analysis.v1.VideoTrack video_tracks = 3; */
        for (let i = 0; i < message.videoTracks.length; i++)
            VideoTrack.internalBinaryWrite(message.videoTracks[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated mediacorral.analysis.v1.AudioTrack audio_tracks = 4; */
        for (let i = 0; i < message.audioTracks.length; i++)
            AudioTrack.internalBinaryWrite(message.audioTracks[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated mediacorral.analysis.v1.SubtitleTrack subtitle_tracks = 5; */
        for (let i = 0; i < message.subtitleTracks.length; i++)
            SubtitleTrack.internalBinaryWrite(message.subtitleTracks[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string name = 6; */
        if (message.name !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mediacorral.analysis.v1.MediaDetails
 */
export const MediaDetails = new MediaDetails$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChapterInfo$Type extends MessageType<ChapterInfo> {
    constructor() {
        super("mediacorral.analysis.v1.ChapterInfo", [
            { no: 1, name: "chapter_number", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "chapter_uid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "chapter_start_ns", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "chapter_end_ns", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "chapter_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ChapterInfo>): ChapterInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.chapterNumber = 0;
        message.chapterUid = 0n;
        message.chapterStartNs = 0n;
        message.chapterEndNs = 0n;
        message.chapterName = "";
        if (value !== undefined)
            reflectionMergePartial<ChapterInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChapterInfo): ChapterInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 chapter_number */ 1:
                    message.chapterNumber = reader.uint32();
                    break;
                case /* uint64 chapter_uid */ 2:
                    message.chapterUid = reader.uint64().toBigInt();
                    break;
                case /* uint64 chapter_start_ns */ 3:
                    message.chapterStartNs = reader.uint64().toBigInt();
                    break;
                case /* uint64 chapter_end_ns */ 4:
                    message.chapterEndNs = reader.uint64().toBigInt();
                    break;
                case /* string chapter_name */ 5:
                    message.chapterName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChapterInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 chapter_number = 1; */
        if (message.chapterNumber !== 0)
            writer.tag(1, WireType.Varint).uint32(message.chapterNumber);
        /* uint64 chapter_uid = 2; */
        if (message.chapterUid !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.chapterUid);
        /* uint64 chapter_start_ns = 3; */
        if (message.chapterStartNs !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.chapterStartNs);
        /* uint64 chapter_end_ns = 4; */
        if (message.chapterEndNs !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.chapterEndNs);
        /* string chapter_name = 5; */
        if (message.chapterName !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.chapterName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mediacorral.analysis.v1.ChapterInfo
 */
export const ChapterInfo = new ChapterInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VideoTrack$Type extends MessageType<VideoTrack> {
    constructor() {
        super("mediacorral.analysis.v1.VideoTrack", [
            { no: 1, name: "track_number", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "track_uid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "enabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "default", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "commentary", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "original", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "visual_impaired", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "language", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "codec_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "stereo_mode", kind: "enum", T: () => ["mediacorral.analysis.v1.VideoStereoMode", VideoStereoMode, "VIDEO_STEREO_MODE_"] },
            { no: 13, name: "display_width", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 14, name: "display_height", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<VideoTrack>): VideoTrack {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.trackNumber = 0n;
        message.trackUid = 0n;
        message.hash = new Uint8Array(0);
        message.enabled = false;
        message.default = false;
        message.commentary = false;
        message.original = false;
        message.visualImpaired = false;
        message.codecId = "";
        message.stereoMode = 0;
        message.displayWidth = 0n;
        message.displayHeight = 0n;
        if (value !== undefined)
            reflectionMergePartial<VideoTrack>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VideoTrack): VideoTrack {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 track_number */ 1:
                    message.trackNumber = reader.uint64().toBigInt();
                    break;
                case /* uint64 track_uid */ 2:
                    message.trackUid = reader.uint64().toBigInt();
                    break;
                case /* bytes hash */ 3:
                    message.hash = reader.bytes();
                    break;
                case /* bool enabled */ 4:
                    message.enabled = reader.bool();
                    break;
                case /* bool default */ 5:
                    message.default = reader.bool();
                    break;
                case /* bool commentary */ 6:
                    message.commentary = reader.bool();
                    break;
                case /* bool original */ 7:
                    message.original = reader.bool();
                    break;
                case /* bool visual_impaired */ 8:
                    message.visualImpaired = reader.bool();
                    break;
                case /* optional string name */ 9:
                    message.name = reader.string();
                    break;
                case /* optional string language */ 10:
                    message.language = reader.string();
                    break;
                case /* string codec_id */ 11:
                    message.codecId = reader.string();
                    break;
                case /* mediacorral.analysis.v1.VideoStereoMode stereo_mode */ 12:
                    message.stereoMode = reader.int32();
                    break;
                case /* uint64 display_width */ 13:
                    message.displayWidth = reader.uint64().toBigInt();
                    break;
                case /* uint64 display_height */ 14:
                    message.displayHeight = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VideoTrack, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 track_number = 1; */
        if (message.trackNumber !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.trackNumber);
        /* uint64 track_uid = 2; */
        if (message.trackUid !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.trackUid);
        /* bytes hash = 3; */
        if (message.hash.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.hash);
        /* bool enabled = 4; */
        if (message.enabled !== false)
            writer.tag(4, WireType.Varint).bool(message.enabled);
        /* bool default = 5; */
        if (message.default !== false)
            writer.tag(5, WireType.Varint).bool(message.default);
        /* bool commentary = 6; */
        if (message.commentary !== false)
            writer.tag(6, WireType.Varint).bool(message.commentary);
        /* bool original = 7; */
        if (message.original !== false)
            writer.tag(7, WireType.Varint).bool(message.original);
        /* bool visual_impaired = 8; */
        if (message.visualImpaired !== false)
            writer.tag(8, WireType.Varint).bool(message.visualImpaired);
        /* optional string name = 9; */
        if (message.name !== undefined)
            writer.tag(9, WireType.LengthDelimited).string(message.name);
        /* optional string language = 10; */
        if (message.language !== undefined)
            writer.tag(10, WireType.LengthDelimited).string(message.language);
        /* string codec_id = 11; */
        if (message.codecId !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.codecId);
        /* mediacorral.analysis.v1.VideoStereoMode stereo_mode = 12; */
        if (message.stereoMode !== 0)
            writer.tag(12, WireType.Varint).int32(message.stereoMode);
        /* uint64 display_width = 13; */
        if (message.displayWidth !== 0n)
            writer.tag(13, WireType.Varint).uint64(message.displayWidth);
        /* uint64 display_height = 14; */
        if (message.displayHeight !== 0n)
            writer.tag(14, WireType.Varint).uint64(message.displayHeight);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mediacorral.analysis.v1.VideoTrack
 */
export const VideoTrack = new VideoTrack$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AudioTrack$Type extends MessageType<AudioTrack> {
    constructor() {
        super("mediacorral.analysis.v1.AudioTrack", [
            { no: 1, name: "track_number", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "track_uid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "enabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "default", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "commentary", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "original", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "visual_impaired", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "language", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "codec_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "channels", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<AudioTrack>): AudioTrack {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.trackNumber = 0n;
        message.trackUid = 0n;
        message.hash = new Uint8Array(0);
        message.enabled = false;
        message.default = false;
        message.commentary = false;
        message.original = false;
        message.visualImpaired = false;
        message.codecId = "";
        message.channels = 0n;
        if (value !== undefined)
            reflectionMergePartial<AudioTrack>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AudioTrack): AudioTrack {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 track_number */ 1:
                    message.trackNumber = reader.uint64().toBigInt();
                    break;
                case /* uint64 track_uid */ 2:
                    message.trackUid = reader.uint64().toBigInt();
                    break;
                case /* bytes hash */ 3:
                    message.hash = reader.bytes();
                    break;
                case /* bool enabled */ 4:
                    message.enabled = reader.bool();
                    break;
                case /* bool default */ 5:
                    message.default = reader.bool();
                    break;
                case /* bool commentary */ 6:
                    message.commentary = reader.bool();
                    break;
                case /* bool original */ 7:
                    message.original = reader.bool();
                    break;
                case /* bool visual_impaired */ 8:
                    message.visualImpaired = reader.bool();
                    break;
                case /* optional string name */ 9:
                    message.name = reader.string();
                    break;
                case /* optional string language */ 10:
                    message.language = reader.string();
                    break;
                case /* string codec_id */ 11:
                    message.codecId = reader.string();
                    break;
                case /* uint64 channels */ 12:
                    message.channels = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AudioTrack, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 track_number = 1; */
        if (message.trackNumber !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.trackNumber);
        /* uint64 track_uid = 2; */
        if (message.trackUid !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.trackUid);
        /* bytes hash = 3; */
        if (message.hash.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.hash);
        /* bool enabled = 4; */
        if (message.enabled !== false)
            writer.tag(4, WireType.Varint).bool(message.enabled);
        /* bool default = 5; */
        if (message.default !== false)
            writer.tag(5, WireType.Varint).bool(message.default);
        /* bool commentary = 6; */
        if (message.commentary !== false)
            writer.tag(6, WireType.Varint).bool(message.commentary);
        /* bool original = 7; */
        if (message.original !== false)
            writer.tag(7, WireType.Varint).bool(message.original);
        /* bool visual_impaired = 8; */
        if (message.visualImpaired !== false)
            writer.tag(8, WireType.Varint).bool(message.visualImpaired);
        /* optional string name = 9; */
        if (message.name !== undefined)
            writer.tag(9, WireType.LengthDelimited).string(message.name);
        /* optional string language = 10; */
        if (message.language !== undefined)
            writer.tag(10, WireType.LengthDelimited).string(message.language);
        /* string codec_id = 11; */
        if (message.codecId !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.codecId);
        /* uint64 channels = 12; */
        if (message.channels !== 0n)
            writer.tag(12, WireType.Varint).uint64(message.channels);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mediacorral.analysis.v1.AudioTrack
 */
export const AudioTrack = new AudioTrack$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubtitleTrack$Type extends MessageType<SubtitleTrack> {
    constructor() {
        super("mediacorral.analysis.v1.SubtitleTrack", [
            { no: 1, name: "track_number", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "track_uid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "enabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "default", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "commentary", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "original", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "visual_impaired", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "language", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "codec_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SubtitleTrack>): SubtitleTrack {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.trackNumber = 0n;
        message.trackUid = 0n;
        message.hash = new Uint8Array(0);
        message.enabled = false;
        message.default = false;
        message.commentary = false;
        message.original = false;
        message.visualImpaired = false;
        message.codecId = "";
        if (value !== undefined)
            reflectionMergePartial<SubtitleTrack>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubtitleTrack): SubtitleTrack {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 track_number */ 1:
                    message.trackNumber = reader.uint64().toBigInt();
                    break;
                case /* uint64 track_uid */ 2:
                    message.trackUid = reader.uint64().toBigInt();
                    break;
                case /* bytes hash */ 3:
                    message.hash = reader.bytes();
                    break;
                case /* bool enabled */ 4:
                    message.enabled = reader.bool();
                    break;
                case /* bool default */ 5:
                    message.default = reader.bool();
                    break;
                case /* bool commentary */ 6:
                    message.commentary = reader.bool();
                    break;
                case /* bool original */ 7:
                    message.original = reader.bool();
                    break;
                case /* bool visual_impaired */ 8:
                    message.visualImpaired = reader.bool();
                    break;
                case /* optional string name */ 9:
                    message.name = reader.string();
                    break;
                case /* optional string language */ 10:
                    message.language = reader.string();
                    break;
                case /* string codec_id */ 11:
                    message.codecId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubtitleTrack, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 track_number = 1; */
        if (message.trackNumber !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.trackNumber);
        /* uint64 track_uid = 2; */
        if (message.trackUid !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.trackUid);
        /* bytes hash = 3; */
        if (message.hash.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.hash);
        /* bool enabled = 4; */
        if (message.enabled !== false)
            writer.tag(4, WireType.Varint).bool(message.enabled);
        /* bool default = 5; */
        if (message.default !== false)
            writer.tag(5, WireType.Varint).bool(message.default);
        /* bool commentary = 6; */
        if (message.commentary !== false)
            writer.tag(6, WireType.Varint).bool(message.commentary);
        /* bool original = 7; */
        if (message.original !== false)
            writer.tag(7, WireType.Varint).bool(message.original);
        /* bool visual_impaired = 8; */
        if (message.visualImpaired !== false)
            writer.tag(8, WireType.Varint).bool(message.visualImpaired);
        /* optional string name = 9; */
        if (message.name !== undefined)
            writer.tag(9, WireType.LengthDelimited).string(message.name);
        /* optional string language = 10; */
        if (message.language !== undefined)
            writer.tag(10, WireType.LengthDelimited).string(message.language);
        /* string codec_id = 11; */
        if (message.codecId !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.codecId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mediacorral.analysis.v1.SubtitleTrack
 */
export const SubtitleTrack = new SubtitleTrack$Type();
/**
 * @generated ServiceType for protobuf service mediacorral.analysis.v1.MediaAnalysisService
 */
export const MediaAnalysisService = new ServiceType("mediacorral.analysis.v1.MediaAnalysisService", [
    { name: "AnalyzeMkv", options: {}, I: AnalyzeMkvRequest, O: AnalyzeMkvResponse }
]);
