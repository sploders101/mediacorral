// @generated by protobuf-ts 2.11.1 with parameter long_type_bigint
// @generated from protobuf file "mediacorral/drive_controller/v1/main.proto" (package "mediacorral.drive_controller.v1", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message mediacorral.drive_controller.v1.EjectRequest
 */
export interface EjectRequest {
    /**
     * @generated from protobuf field: uint32 drive_id = 1
     */
    driveId: number;
}
/**
 * @generated from protobuf message mediacorral.drive_controller.v1.RetractRequest
 */
export interface RetractRequest {
    /**
     * @generated from protobuf field: uint32 drive_id = 1
     */
    driveId: number;
}
/**
 * @generated from protobuf message mediacorral.drive_controller.v1.GetDriveStateRequest
 */
export interface GetDriveStateRequest {
    /**
     * @generated from protobuf field: uint32 drive_id = 1
     */
    driveId: number;
}
/**
 * @generated from protobuf message mediacorral.drive_controller.v1.GetJobStatusRequest
 */
export interface GetJobStatusRequest {
    /**
     * @generated from protobuf field: int64 job_id = 1
     */
    jobId: bigint;
}
/**
 * @generated from protobuf message mediacorral.drive_controller.v1.WatchRipJobRequest
 */
export interface WatchRipJobRequest {
    /**
     * @generated from protobuf field: int64 job_id = 1
     */
    jobId: bigint;
}
/**
 * @generated from protobuf message mediacorral.drive_controller.v1.GetDriveCountRequest
 */
export interface GetDriveCountRequest {
}
/**
 * @generated from protobuf message mediacorral.drive_controller.v1.EjectResponse
 */
export interface EjectResponse {
}
/**
 * @generated from protobuf message mediacorral.drive_controller.v1.RetractResponse
 */
export interface RetractResponse {
}
/**
 * @generated from protobuf message mediacorral.drive_controller.v1.RipMediaResponse
 */
export interface RipMediaResponse {
}
/**
 * @generated from protobuf message mediacorral.drive_controller.v1.GetDriveMetaRequest
 */
export interface GetDriveMetaRequest {
    /**
     * @generated from protobuf field: uint32 drive_id = 1
     */
    driveId: number;
}
/**
 * @generated from protobuf message mediacorral.drive_controller.v1.GetDriveCountResponse
 */
export interface GetDriveCountResponse {
    /**
     * @generated from protobuf field: uint32 drive_count = 1
     */
    driveCount: number;
}
/**
 * Metadata about the drive.
 *
 * @generated from protobuf message mediacorral.drive_controller.v1.GetDriveMetaResponse
 */
export interface GetDriveMetaResponse {
    /**
     * The ID of the drive
     *
     * @generated from protobuf field: uint32 drive_id = 1
     */
    driveId: number;
    /**
     * The human-readable name for the drive
     *
     * @generated from protobuf field: string name = 2
     */
    name: string;
}
/**
 * @generated from protobuf message mediacorral.drive_controller.v1.ReapJobRequest
 */
export interface ReapJobRequest {
    /**
     * @generated from protobuf field: int64 job_id = 1
     */
    jobId: bigint;
}
/**
 * @generated from protobuf message mediacorral.drive_controller.v1.ReapJobResponse
 */
export interface ReapJobResponse {
}
/**
 * @generated from protobuf message mediacorral.drive_controller.v1.CommandError
 */
export interface CommandError {
    /**
     * @generated from protobuf field: uint64 code = 1
     */
    code: bigint;
}
/**
 * The current status of the rip job
 *
 * @generated from protobuf message mediacorral.drive_controller.v1.RipStatus
 */
export interface RipStatus {
    /**
     * The ID for this rip job (used in the database)
     *
     * @generated from protobuf field: int64 job_id = 1
     */
    jobId: bigint;
    /**
     * The status of the job (active/completed/error)
     *
     * @generated from protobuf field: mediacorral.drive_controller.v1.JobStatus status = 2
     */
    status: JobStatus;
    /**
     * The "Current Item" progress title
     *
     * @generated from protobuf field: string cprog_title = 3
     */
    cprogTitle: string;
    /**
     * The "Total" progress title
     *
     * @generated from protobuf field: string tprog_title = 4
     */
    tprogTitle: string;
    /**
     * The "Total" progress value
     *
     * @generated from protobuf field: mediacorral.drive_controller.v1.Progress progress = 5
     */
    progress?: Progress;
    /**
     * Text logs from the job
     *
     * @generated from protobuf field: repeated string logs = 6
     */
    logs: string[];
}
/**
 * Represents the current state of the drive
 *
 * @generated from protobuf message mediacorral.drive_controller.v1.DriveState
 */
export interface DriveState {
    /**
     * The ID of the drive
     *
     * @generated from protobuf field: uint32 drive_id = 1
     */
    driveId: number;
    /**
     * Status enumeration
     *
     * @generated from protobuf field: mediacorral.drive_controller.v1.DriveStatusTag status = 2
     */
    status: DriveStatusTag;
    /**
     * The name of the disc in the drive (if any)
     *
     * @generated from protobuf field: optional string disc_name = 3
     */
    discName?: string;
    /**
     * The status of an ongoing rip job
     *
     * @generated from protobuf field: optional int64 active_rip_job = 5
     */
    activeRipJob?: bigint;
}
/**
 * A request to rip media
 *
 * @generated from protobuf message mediacorral.drive_controller.v1.RipMediaRequest
 */
export interface RipMediaRequest {
    /**
     * The ID for the rip job (used in the database)
     *
     * @generated from protobuf field: int64 job_id = 1
     */
    jobId: bigint;
    /**
     * The ID of the drive to start a rip job for
     *
     * @generated from protobuf field: uint32 drive_id = 2
     */
    driveId: number;
    /**
     * Whether to automatically eject the drive when the rip job is complete
     *
     * @generated from protobuf field: bool autoeject = 3
     */
    autoeject: boolean;
}
/**
 * Represents progress as a fraction
 *
 * @generated from protobuf message mediacorral.drive_controller.v1.Progress
 */
export interface Progress {
    /**
     * @generated from protobuf field: uint32 cprog_value = 1
     */
    cprogValue: number;
    /**
     * @generated from protobuf field: uint32 tprog_value = 2
     */
    tprogValue: number;
    /**
     * @generated from protobuf field: uint32 max_value = 3
     */
    maxValue: number;
}
/**
 * An update to the progress of a rip job
 *
 * @generated from protobuf message mediacorral.drive_controller.v1.RipUpdate
 */
export interface RipUpdate {
    /**
     * @generated from protobuf oneof: rip_update
     */
    ripUpdate: {
        oneofKind: "status";
        /**
         * A status update
         *
         * @generated from protobuf field: mediacorral.drive_controller.v1.JobStatus status = 1
         */
        status: JobStatus;
    } | {
        oneofKind: "cprogTitle";
        /**
         * The "Current Item" progress title
         *
         * @generated from protobuf field: string cprog_title = 2
         */
        cprogTitle: string;
    } | {
        oneofKind: "tprogTitle";
        /**
         * The "Total" progress title
         *
         * @generated from protobuf field: string tprog_title = 3
         */
        tprogTitle: string;
    } | {
        oneofKind: "progressValues";
        /**
         * Progress values
         *
         * @generated from protobuf field: mediacorral.drive_controller.v1.Progress progress_values = 4
         */
        progressValues: Progress;
    } | {
        oneofKind: "logMessage";
        /**
         * Log message
         *
         * @generated from protobuf field: string log_message = 5
         */
        logMessage: string;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf enum mediacorral.drive_controller.v1.DriveStatusTag
 */
export enum DriveStatusTag {
    /**
     * @generated from protobuf enum value: DRIVE_STATUS_TAG_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: DRIVE_STATUS_TAG_EMPTY = 1;
     */
    EMPTY = 1,
    /**
     * @generated from protobuf enum value: DRIVE_STATUS_TAG_TRAY_OPEN = 2;
     */
    TRAY_OPEN = 2,
    /**
     * @generated from protobuf enum value: DRIVE_STATUS_TAG_NOT_READY = 3;
     */
    NOT_READY = 3,
    /**
     * @generated from protobuf enum value: DRIVE_STATUS_TAG_DISC_LOADED = 4;
     */
    DISC_LOADED = 4
}
/**
 * @generated from protobuf enum mediacorral.drive_controller.v1.JobStatus
 */
export enum JobStatus {
    /**
     * @generated from protobuf enum value: JOB_STATUS_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: JOB_STATUS_RUNNING = 1;
     */
    RUNNING = 1,
    /**
     * @generated from protobuf enum value: JOB_STATUS_COMPLETED = 2;
     */
    COMPLETED = 2,
    /**
     * @generated from protobuf enum value: JOB_STATUS_ERROR = 3;
     */
    ERROR = 3
}
// @generated message type with reflection information, may provide speed optimized methods
class EjectRequest$Type extends MessageType<EjectRequest> {
    constructor() {
        super("mediacorral.drive_controller.v1.EjectRequest", [
            { no: 1, name: "drive_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<EjectRequest>): EjectRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.driveId = 0;
        if (value !== undefined)
            reflectionMergePartial<EjectRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EjectRequest): EjectRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 drive_id */ 1:
                    message.driveId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EjectRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 drive_id = 1; */
        if (message.driveId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.driveId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mediacorral.drive_controller.v1.EjectRequest
 */
export const EjectRequest = new EjectRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetractRequest$Type extends MessageType<RetractRequest> {
    constructor() {
        super("mediacorral.drive_controller.v1.RetractRequest", [
            { no: 1, name: "drive_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<RetractRequest>): RetractRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.driveId = 0;
        if (value !== undefined)
            reflectionMergePartial<RetractRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetractRequest): RetractRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 drive_id */ 1:
                    message.driveId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RetractRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 drive_id = 1; */
        if (message.driveId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.driveId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mediacorral.drive_controller.v1.RetractRequest
 */
export const RetractRequest = new RetractRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDriveStateRequest$Type extends MessageType<GetDriveStateRequest> {
    constructor() {
        super("mediacorral.drive_controller.v1.GetDriveStateRequest", [
            { no: 1, name: "drive_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetDriveStateRequest>): GetDriveStateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.driveId = 0;
        if (value !== undefined)
            reflectionMergePartial<GetDriveStateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDriveStateRequest): GetDriveStateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 drive_id */ 1:
                    message.driveId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDriveStateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 drive_id = 1; */
        if (message.driveId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.driveId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mediacorral.drive_controller.v1.GetDriveStateRequest
 */
export const GetDriveStateRequest = new GetDriveStateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetJobStatusRequest$Type extends MessageType<GetJobStatusRequest> {
    constructor() {
        super("mediacorral.drive_controller.v1.GetJobStatusRequest", [
            { no: 1, name: "job_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<GetJobStatusRequest>): GetJobStatusRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.jobId = 0n;
        if (value !== undefined)
            reflectionMergePartial<GetJobStatusRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetJobStatusRequest): GetJobStatusRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 job_id */ 1:
                    message.jobId = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetJobStatusRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 job_id = 1; */
        if (message.jobId !== 0n)
            writer.tag(1, WireType.Varint).int64(message.jobId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mediacorral.drive_controller.v1.GetJobStatusRequest
 */
export const GetJobStatusRequest = new GetJobStatusRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WatchRipJobRequest$Type extends MessageType<WatchRipJobRequest> {
    constructor() {
        super("mediacorral.drive_controller.v1.WatchRipJobRequest", [
            { no: 1, name: "job_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<WatchRipJobRequest>): WatchRipJobRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.jobId = 0n;
        if (value !== undefined)
            reflectionMergePartial<WatchRipJobRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WatchRipJobRequest): WatchRipJobRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 job_id */ 1:
                    message.jobId = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WatchRipJobRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 job_id = 1; */
        if (message.jobId !== 0n)
            writer.tag(1, WireType.Varint).int64(message.jobId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mediacorral.drive_controller.v1.WatchRipJobRequest
 */
export const WatchRipJobRequest = new WatchRipJobRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDriveCountRequest$Type extends MessageType<GetDriveCountRequest> {
    constructor() {
        super("mediacorral.drive_controller.v1.GetDriveCountRequest", []);
    }
    create(value?: PartialMessage<GetDriveCountRequest>): GetDriveCountRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetDriveCountRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDriveCountRequest): GetDriveCountRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDriveCountRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mediacorral.drive_controller.v1.GetDriveCountRequest
 */
export const GetDriveCountRequest = new GetDriveCountRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EjectResponse$Type extends MessageType<EjectResponse> {
    constructor() {
        super("mediacorral.drive_controller.v1.EjectResponse", []);
    }
    create(value?: PartialMessage<EjectResponse>): EjectResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<EjectResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EjectResponse): EjectResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EjectResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mediacorral.drive_controller.v1.EjectResponse
 */
export const EjectResponse = new EjectResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetractResponse$Type extends MessageType<RetractResponse> {
    constructor() {
        super("mediacorral.drive_controller.v1.RetractResponse", []);
    }
    create(value?: PartialMessage<RetractResponse>): RetractResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RetractResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetractResponse): RetractResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RetractResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mediacorral.drive_controller.v1.RetractResponse
 */
export const RetractResponse = new RetractResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RipMediaResponse$Type extends MessageType<RipMediaResponse> {
    constructor() {
        super("mediacorral.drive_controller.v1.RipMediaResponse", []);
    }
    create(value?: PartialMessage<RipMediaResponse>): RipMediaResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RipMediaResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RipMediaResponse): RipMediaResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RipMediaResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mediacorral.drive_controller.v1.RipMediaResponse
 */
export const RipMediaResponse = new RipMediaResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDriveMetaRequest$Type extends MessageType<GetDriveMetaRequest> {
    constructor() {
        super("mediacorral.drive_controller.v1.GetDriveMetaRequest", [
            { no: 1, name: "drive_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetDriveMetaRequest>): GetDriveMetaRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.driveId = 0;
        if (value !== undefined)
            reflectionMergePartial<GetDriveMetaRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDriveMetaRequest): GetDriveMetaRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 drive_id */ 1:
                    message.driveId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDriveMetaRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 drive_id = 1; */
        if (message.driveId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.driveId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mediacorral.drive_controller.v1.GetDriveMetaRequest
 */
export const GetDriveMetaRequest = new GetDriveMetaRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDriveCountResponse$Type extends MessageType<GetDriveCountResponse> {
    constructor() {
        super("mediacorral.drive_controller.v1.GetDriveCountResponse", [
            { no: 1, name: "drive_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetDriveCountResponse>): GetDriveCountResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.driveCount = 0;
        if (value !== undefined)
            reflectionMergePartial<GetDriveCountResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDriveCountResponse): GetDriveCountResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 drive_count */ 1:
                    message.driveCount = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDriveCountResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 drive_count = 1; */
        if (message.driveCount !== 0)
            writer.tag(1, WireType.Varint).uint32(message.driveCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mediacorral.drive_controller.v1.GetDriveCountResponse
 */
export const GetDriveCountResponse = new GetDriveCountResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDriveMetaResponse$Type extends MessageType<GetDriveMetaResponse> {
    constructor() {
        super("mediacorral.drive_controller.v1.GetDriveMetaResponse", [
            { no: 1, name: "drive_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetDriveMetaResponse>): GetDriveMetaResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.driveId = 0;
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<GetDriveMetaResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDriveMetaResponse): GetDriveMetaResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 drive_id */ 1:
                    message.driveId = reader.uint32();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDriveMetaResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 drive_id = 1; */
        if (message.driveId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.driveId);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mediacorral.drive_controller.v1.GetDriveMetaResponse
 */
export const GetDriveMetaResponse = new GetDriveMetaResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReapJobRequest$Type extends MessageType<ReapJobRequest> {
    constructor() {
        super("mediacorral.drive_controller.v1.ReapJobRequest", [
            { no: 1, name: "job_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<ReapJobRequest>): ReapJobRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.jobId = 0n;
        if (value !== undefined)
            reflectionMergePartial<ReapJobRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReapJobRequest): ReapJobRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 job_id */ 1:
                    message.jobId = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReapJobRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 job_id = 1; */
        if (message.jobId !== 0n)
            writer.tag(1, WireType.Varint).int64(message.jobId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mediacorral.drive_controller.v1.ReapJobRequest
 */
export const ReapJobRequest = new ReapJobRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReapJobResponse$Type extends MessageType<ReapJobResponse> {
    constructor() {
        super("mediacorral.drive_controller.v1.ReapJobResponse", []);
    }
    create(value?: PartialMessage<ReapJobResponse>): ReapJobResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ReapJobResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReapJobResponse): ReapJobResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReapJobResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mediacorral.drive_controller.v1.ReapJobResponse
 */
export const ReapJobResponse = new ReapJobResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandError$Type extends MessageType<CommandError> {
    constructor() {
        super("mediacorral.drive_controller.v1.CommandError", [
            { no: 1, name: "code", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CommandError>): CommandError {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.code = 0n;
        if (value !== undefined)
            reflectionMergePartial<CommandError>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CommandError): CommandError {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 code */ 1:
                    message.code = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CommandError, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 code = 1; */
        if (message.code !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mediacorral.drive_controller.v1.CommandError
 */
export const CommandError = new CommandError$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RipStatus$Type extends MessageType<RipStatus> {
    constructor() {
        super("mediacorral.drive_controller.v1.RipStatus", [
            { no: 1, name: "job_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "status", kind: "enum", T: () => ["mediacorral.drive_controller.v1.JobStatus", JobStatus, "JOB_STATUS_"] },
            { no: 3, name: "cprog_title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "tprog_title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "progress", kind: "message", T: () => Progress },
            { no: 6, name: "logs", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RipStatus>): RipStatus {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.jobId = 0n;
        message.status = 0;
        message.cprogTitle = "";
        message.tprogTitle = "";
        message.logs = [];
        if (value !== undefined)
            reflectionMergePartial<RipStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RipStatus): RipStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 job_id */ 1:
                    message.jobId = reader.int64().toBigInt();
                    break;
                case /* mediacorral.drive_controller.v1.JobStatus status */ 2:
                    message.status = reader.int32();
                    break;
                case /* string cprog_title */ 3:
                    message.cprogTitle = reader.string();
                    break;
                case /* string tprog_title */ 4:
                    message.tprogTitle = reader.string();
                    break;
                case /* mediacorral.drive_controller.v1.Progress progress */ 5:
                    message.progress = Progress.internalBinaryRead(reader, reader.uint32(), options, message.progress);
                    break;
                case /* repeated string logs */ 6:
                    message.logs.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RipStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 job_id = 1; */
        if (message.jobId !== 0n)
            writer.tag(1, WireType.Varint).int64(message.jobId);
        /* mediacorral.drive_controller.v1.JobStatus status = 2; */
        if (message.status !== 0)
            writer.tag(2, WireType.Varint).int32(message.status);
        /* string cprog_title = 3; */
        if (message.cprogTitle !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.cprogTitle);
        /* string tprog_title = 4; */
        if (message.tprogTitle !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.tprogTitle);
        /* mediacorral.drive_controller.v1.Progress progress = 5; */
        if (message.progress)
            Progress.internalBinaryWrite(message.progress, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated string logs = 6; */
        for (let i = 0; i < message.logs.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.logs[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mediacorral.drive_controller.v1.RipStatus
 */
export const RipStatus = new RipStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DriveState$Type extends MessageType<DriveState> {
    constructor() {
        super("mediacorral.drive_controller.v1.DriveState", [
            { no: 1, name: "drive_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "status", kind: "enum", T: () => ["mediacorral.drive_controller.v1.DriveStatusTag", DriveStatusTag, "DRIVE_STATUS_TAG_"] },
            { no: 3, name: "disc_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "active_rip_job", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<DriveState>): DriveState {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.driveId = 0;
        message.status = 0;
        if (value !== undefined)
            reflectionMergePartial<DriveState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DriveState): DriveState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 drive_id */ 1:
                    message.driveId = reader.uint32();
                    break;
                case /* mediacorral.drive_controller.v1.DriveStatusTag status */ 2:
                    message.status = reader.int32();
                    break;
                case /* optional string disc_name */ 3:
                    message.discName = reader.string();
                    break;
                case /* optional int64 active_rip_job */ 5:
                    message.activeRipJob = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DriveState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 drive_id = 1; */
        if (message.driveId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.driveId);
        /* mediacorral.drive_controller.v1.DriveStatusTag status = 2; */
        if (message.status !== 0)
            writer.tag(2, WireType.Varint).int32(message.status);
        /* optional string disc_name = 3; */
        if (message.discName !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.discName);
        /* optional int64 active_rip_job = 5; */
        if (message.activeRipJob !== undefined)
            writer.tag(5, WireType.Varint).int64(message.activeRipJob);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mediacorral.drive_controller.v1.DriveState
 */
export const DriveState = new DriveState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RipMediaRequest$Type extends MessageType<RipMediaRequest> {
    constructor() {
        super("mediacorral.drive_controller.v1.RipMediaRequest", [
            { no: 1, name: "job_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "drive_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "autoeject", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<RipMediaRequest>): RipMediaRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.jobId = 0n;
        message.driveId = 0;
        message.autoeject = false;
        if (value !== undefined)
            reflectionMergePartial<RipMediaRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RipMediaRequest): RipMediaRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 job_id */ 1:
                    message.jobId = reader.int64().toBigInt();
                    break;
                case /* uint32 drive_id */ 2:
                    message.driveId = reader.uint32();
                    break;
                case /* bool autoeject */ 3:
                    message.autoeject = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RipMediaRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 job_id = 1; */
        if (message.jobId !== 0n)
            writer.tag(1, WireType.Varint).int64(message.jobId);
        /* uint32 drive_id = 2; */
        if (message.driveId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.driveId);
        /* bool autoeject = 3; */
        if (message.autoeject !== false)
            writer.tag(3, WireType.Varint).bool(message.autoeject);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mediacorral.drive_controller.v1.RipMediaRequest
 */
export const RipMediaRequest = new RipMediaRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Progress$Type extends MessageType<Progress> {
    constructor() {
        super("mediacorral.drive_controller.v1.Progress", [
            { no: 1, name: "cprog_value", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "tprog_value", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "max_value", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<Progress>): Progress {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.cprogValue = 0;
        message.tprogValue = 0;
        message.maxValue = 0;
        if (value !== undefined)
            reflectionMergePartial<Progress>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Progress): Progress {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 cprog_value */ 1:
                    message.cprogValue = reader.uint32();
                    break;
                case /* uint32 tprog_value */ 2:
                    message.tprogValue = reader.uint32();
                    break;
                case /* uint32 max_value */ 3:
                    message.maxValue = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Progress, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 cprog_value = 1; */
        if (message.cprogValue !== 0)
            writer.tag(1, WireType.Varint).uint32(message.cprogValue);
        /* uint32 tprog_value = 2; */
        if (message.tprogValue !== 0)
            writer.tag(2, WireType.Varint).uint32(message.tprogValue);
        /* uint32 max_value = 3; */
        if (message.maxValue !== 0)
            writer.tag(3, WireType.Varint).uint32(message.maxValue);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mediacorral.drive_controller.v1.Progress
 */
export const Progress = new Progress$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RipUpdate$Type extends MessageType<RipUpdate> {
    constructor() {
        super("mediacorral.drive_controller.v1.RipUpdate", [
            { no: 1, name: "status", kind: "enum", oneof: "ripUpdate", T: () => ["mediacorral.drive_controller.v1.JobStatus", JobStatus, "JOB_STATUS_"] },
            { no: 2, name: "cprog_title", kind: "scalar", oneof: "ripUpdate", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "tprog_title", kind: "scalar", oneof: "ripUpdate", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "progress_values", kind: "message", oneof: "ripUpdate", T: () => Progress },
            { no: 5, name: "log_message", kind: "scalar", oneof: "ripUpdate", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RipUpdate>): RipUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ripUpdate = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<RipUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RipUpdate): RipUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mediacorral.drive_controller.v1.JobStatus status */ 1:
                    message.ripUpdate = {
                        oneofKind: "status",
                        status: reader.int32()
                    };
                    break;
                case /* string cprog_title */ 2:
                    message.ripUpdate = {
                        oneofKind: "cprogTitle",
                        cprogTitle: reader.string()
                    };
                    break;
                case /* string tprog_title */ 3:
                    message.ripUpdate = {
                        oneofKind: "tprogTitle",
                        tprogTitle: reader.string()
                    };
                    break;
                case /* mediacorral.drive_controller.v1.Progress progress_values */ 4:
                    message.ripUpdate = {
                        oneofKind: "progressValues",
                        progressValues: Progress.internalBinaryRead(reader, reader.uint32(), options, (message.ripUpdate as any).progressValues)
                    };
                    break;
                case /* string log_message */ 5:
                    message.ripUpdate = {
                        oneofKind: "logMessage",
                        logMessage: reader.string()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RipUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mediacorral.drive_controller.v1.JobStatus status = 1; */
        if (message.ripUpdate.oneofKind === "status")
            writer.tag(1, WireType.Varint).int32(message.ripUpdate.status);
        /* string cprog_title = 2; */
        if (message.ripUpdate.oneofKind === "cprogTitle")
            writer.tag(2, WireType.LengthDelimited).string(message.ripUpdate.cprogTitle);
        /* string tprog_title = 3; */
        if (message.ripUpdate.oneofKind === "tprogTitle")
            writer.tag(3, WireType.LengthDelimited).string(message.ripUpdate.tprogTitle);
        /* mediacorral.drive_controller.v1.Progress progress_values = 4; */
        if (message.ripUpdate.oneofKind === "progressValues")
            Progress.internalBinaryWrite(message.ripUpdate.progressValues, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string log_message = 5; */
        if (message.ripUpdate.oneofKind === "logMessage")
            writer.tag(5, WireType.LengthDelimited).string(message.ripUpdate.logMessage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mediacorral.drive_controller.v1.RipUpdate
 */
export const RipUpdate = new RipUpdate$Type();
/**
 * @generated ServiceType for protobuf service mediacorral.drive_controller.v1.DriveControllerService
 */
export const DriveControllerService = new ServiceType("mediacorral.drive_controller.v1.DriveControllerService", [
    { name: "GetDriveCount", options: {}, I: GetDriveCountRequest, O: GetDriveCountResponse },
    { name: "GetDriveMeta", options: {}, I: GetDriveMetaRequest, O: GetDriveMetaResponse },
    { name: "Eject", options: {}, I: EjectRequest, O: EjectResponse },
    { name: "Retract", options: {}, I: RetractRequest, O: RetractResponse },
    { name: "GetDriveState", options: {}, I: GetDriveStateRequest, O: DriveState },
    { name: "RipMedia", options: {}, I: RipMediaRequest, O: RipMediaResponse },
    { name: "GetJobStatus", options: {}, I: GetJobStatusRequest, O: RipStatus },
    { name: "WatchRipJob", serverStreaming: true, options: {}, I: WatchRipJobRequest, O: RipUpdate },
    { name: "ReapJob", options: {}, I: ReapJobRequest, O: ReapJobResponse }
]);
