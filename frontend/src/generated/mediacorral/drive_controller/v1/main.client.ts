// @generated by protobuf-ts 2.11.1 with parameter long_type_bigint
// @generated from protobuf file "mediacorral/drive_controller/v1/main.proto" (package "mediacorral.drive_controller.v1", syntax proto3)
// tslint:disable
import type { RpcTransport } from "@protobuf-ts/runtime-rpc";
import type { ServiceInfo } from "@protobuf-ts/runtime-rpc";
import { DriveControllerService } from "./main";
import type { ReapJobResponse } from "./main";
import type { ReapJobRequest } from "./main";
import type { RipUpdate } from "./main";
import type { WatchRipJobRequest } from "./main";
import type { ServerStreamingCall } from "@protobuf-ts/runtime-rpc";
import type { RipStatus } from "./main";
import type { GetJobStatusRequest } from "./main";
import type { RipMediaResponse } from "./main";
import type { RipMediaRequest } from "./main";
import type { DriveState } from "./main";
import type { GetDriveStateRequest } from "./main";
import type { RetractResponse } from "./main";
import type { RetractRequest } from "./main";
import type { EjectResponse } from "./main";
import type { EjectRequest } from "./main";
import type { GetDriveMetaResponse } from "./main";
import type { GetDriveMetaRequest } from "./main";
import { stackIntercept } from "@protobuf-ts/runtime-rpc";
import type { GetDriveCountResponse } from "./main";
import type { GetDriveCountRequest } from "./main";
import type { UnaryCall } from "@protobuf-ts/runtime-rpc";
import type { RpcOptions } from "@protobuf-ts/runtime-rpc";
/**
 * @generated from protobuf service mediacorral.drive_controller.v1.DriveControllerService
 */
export interface IDriveControllerServiceClient {
    /**
     * Gets the number of drives registered with this controller.
     * Drive IDs are a contiguous sequence starting from 0, going up to
     * (but not including) the result of this function.
     *
     * @generated from protobuf rpc: GetDriveCount
     */
    getDriveCount(input: GetDriveCountRequest, options?: RpcOptions): UnaryCall<GetDriveCountRequest, GetDriveCountResponse>;
    /**
     * Get metadata about the drive
     *
     * @generated from protobuf rpc: GetDriveMeta
     */
    getDriveMeta(input: GetDriveMetaRequest, options?: RpcOptions): UnaryCall<GetDriveMetaRequest, GetDriveMetaResponse>;
    /**
     * Ejects the disc in the drive
     *
     * @generated from protobuf rpc: Eject
     */
    eject(input: EjectRequest, options?: RpcOptions): UnaryCall<EjectRequest, EjectResponse>;
    /**
     * Retracts the disc in the drive
     *
     * @generated from protobuf rpc: Retract
     */
    retract(input: RetractRequest, options?: RpcOptions): UnaryCall<RetractRequest, RetractResponse>;
    /**
     * Gets the current state of the drive
     *
     * @generated from protobuf rpc: GetDriveState
     */
    getDriveState(input: GetDriveStateRequest, options?: RpcOptions): UnaryCall<GetDriveStateRequest, DriveState>;
    /**
     * Rips the media in the drive. Returns immediately. Status changes
     * come through the FollowRipJob stream.
     *
     * @generated from protobuf rpc: RipMedia
     */
    ripMedia(input: RipMediaRequest, options?: RpcOptions): UnaryCall<RipMediaRequest, RipMediaResponse>;
    /**
     * Requests the current status of a job
     *
     * @generated from protobuf rpc: GetJobStatus
     */
    getJobStatus(input: GetJobStatusRequest, options?: RpcOptions): UnaryCall<GetJobStatusRequest, RipStatus>;
    /**
     * Creates a stream of RipUpdate responses, useful for monitoring the
     * real-time status of a job
     *
     * @generated from protobuf rpc: WatchRipJob
     */
    watchRipJob(input: WatchRipJobRequest, options?: RpcOptions): ServerStreamingCall<WatchRipJobRequest, RipUpdate>;
    /**
     * Reap the job, deleting it from the in-memory cache.
     * This is meant to be called by the server after uploading relevant
     * details to the database.
     *
     * @generated from protobuf rpc: ReapJob
     */
    reapJob(input: ReapJobRequest, options?: RpcOptions): UnaryCall<ReapJobRequest, ReapJobResponse>;
}
/**
 * @generated from protobuf service mediacorral.drive_controller.v1.DriveControllerService
 */
export class DriveControllerServiceClient implements IDriveControllerServiceClient, ServiceInfo {
    typeName = DriveControllerService.typeName;
    methods = DriveControllerService.methods;
    options = DriveControllerService.options;
    constructor(private readonly _transport: RpcTransport) {
    }
    /**
     * Gets the number of drives registered with this controller.
     * Drive IDs are a contiguous sequence starting from 0, going up to
     * (but not including) the result of this function.
     *
     * @generated from protobuf rpc: GetDriveCount
     */
    getDriveCount(input: GetDriveCountRequest, options?: RpcOptions): UnaryCall<GetDriveCountRequest, GetDriveCountResponse> {
        const method = this.methods[0], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetDriveCountRequest, GetDriveCountResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Get metadata about the drive
     *
     * @generated from protobuf rpc: GetDriveMeta
     */
    getDriveMeta(input: GetDriveMetaRequest, options?: RpcOptions): UnaryCall<GetDriveMetaRequest, GetDriveMetaResponse> {
        const method = this.methods[1], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetDriveMetaRequest, GetDriveMetaResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Ejects the disc in the drive
     *
     * @generated from protobuf rpc: Eject
     */
    eject(input: EjectRequest, options?: RpcOptions): UnaryCall<EjectRequest, EjectResponse> {
        const method = this.methods[2], opt = this._transport.mergeOptions(options);
        return stackIntercept<EjectRequest, EjectResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Retracts the disc in the drive
     *
     * @generated from protobuf rpc: Retract
     */
    retract(input: RetractRequest, options?: RpcOptions): UnaryCall<RetractRequest, RetractResponse> {
        const method = this.methods[3], opt = this._transport.mergeOptions(options);
        return stackIntercept<RetractRequest, RetractResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Gets the current state of the drive
     *
     * @generated from protobuf rpc: GetDriveState
     */
    getDriveState(input: GetDriveStateRequest, options?: RpcOptions): UnaryCall<GetDriveStateRequest, DriveState> {
        const method = this.methods[4], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetDriveStateRequest, DriveState>("unary", this._transport, method, opt, input);
    }
    /**
     * Rips the media in the drive. Returns immediately. Status changes
     * come through the FollowRipJob stream.
     *
     * @generated from protobuf rpc: RipMedia
     */
    ripMedia(input: RipMediaRequest, options?: RpcOptions): UnaryCall<RipMediaRequest, RipMediaResponse> {
        const method = this.methods[5], opt = this._transport.mergeOptions(options);
        return stackIntercept<RipMediaRequest, RipMediaResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Requests the current status of a job
     *
     * @generated from protobuf rpc: GetJobStatus
     */
    getJobStatus(input: GetJobStatusRequest, options?: RpcOptions): UnaryCall<GetJobStatusRequest, RipStatus> {
        const method = this.methods[6], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetJobStatusRequest, RipStatus>("unary", this._transport, method, opt, input);
    }
    /**
     * Creates a stream of RipUpdate responses, useful for monitoring the
     * real-time status of a job
     *
     * @generated from protobuf rpc: WatchRipJob
     */
    watchRipJob(input: WatchRipJobRequest, options?: RpcOptions): ServerStreamingCall<WatchRipJobRequest, RipUpdate> {
        const method = this.methods[7], opt = this._transport.mergeOptions(options);
        return stackIntercept<WatchRipJobRequest, RipUpdate>("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * Reap the job, deleting it from the in-memory cache.
     * This is meant to be called by the server after uploading relevant
     * details to the database.
     *
     * @generated from protobuf rpc: ReapJob
     */
    reapJob(input: ReapJobRequest, options?: RpcOptions): UnaryCall<ReapJobRequest, ReapJobResponse> {
        const method = this.methods[8], opt = this._transport.mergeOptions(options);
        return stackIntercept<ReapJobRequest, ReapJobResponse>("unary", this._transport, method, opt, input);
    }
}
