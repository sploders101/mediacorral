// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             (unknown)
// source: mediacorral/drive_controller/v1/main.proto

package drive_controllerv1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	DriveControllerService_GetDriveCount_FullMethodName = "/mediacorral.drive_controller.v1.DriveControllerService/GetDriveCount"
	DriveControllerService_GetDriveMeta_FullMethodName  = "/mediacorral.drive_controller.v1.DriveControllerService/GetDriveMeta"
	DriveControllerService_Eject_FullMethodName         = "/mediacorral.drive_controller.v1.DriveControllerService/Eject"
	DriveControllerService_Retract_FullMethodName       = "/mediacorral.drive_controller.v1.DriveControllerService/Retract"
	DriveControllerService_GetDriveState_FullMethodName = "/mediacorral.drive_controller.v1.DriveControllerService/GetDriveState"
	DriveControllerService_RipMedia_FullMethodName      = "/mediacorral.drive_controller.v1.DriveControllerService/RipMedia"
	DriveControllerService_GetJobStatus_FullMethodName  = "/mediacorral.drive_controller.v1.DriveControllerService/GetJobStatus"
	DriveControllerService_WatchRipJob_FullMethodName   = "/mediacorral.drive_controller.v1.DriveControllerService/WatchRipJob"
	DriveControllerService_ReapJob_FullMethodName       = "/mediacorral.drive_controller.v1.DriveControllerService/ReapJob"
)

// DriveControllerServiceClient is the client API for DriveControllerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DriveControllerServiceClient interface {
	// Gets the number of drives registered with this controller.
	// Drive IDs are a contiguous sequence starting from 0, going up to
	// (but not including) the result of this function.
	GetDriveCount(ctx context.Context, in *GetDriveCountRequest, opts ...grpc.CallOption) (*GetDriveCountResponse, error)
	// Get metadata about the drive
	GetDriveMeta(ctx context.Context, in *GetDriveMetaRequest, opts ...grpc.CallOption) (*GetDriveMetaResponse, error)
	// Ejects the disc in the drive
	Eject(ctx context.Context, in *EjectRequest, opts ...grpc.CallOption) (*EjectResponse, error)
	// Retracts the disc in the drive
	Retract(ctx context.Context, in *RetractRequest, opts ...grpc.CallOption) (*RetractResponse, error)
	// Gets the current state of the drive
	GetDriveState(ctx context.Context, in *GetDriveStateRequest, opts ...grpc.CallOption) (*DriveState, error)
	// Rips the media in the drive. Returns immediately. Status changes
	// come through the FollowRipJob stream.
	RipMedia(ctx context.Context, in *RipMediaRequest, opts ...grpc.CallOption) (*RipMediaResponse, error)
	// Requests the current status of a job
	GetJobStatus(ctx context.Context, in *GetJobStatusRequest, opts ...grpc.CallOption) (*RipStatus, error)
	// Creates a stream of RipUpdate responses, useful for monitoring the
	// real-time status of a job
	WatchRipJob(ctx context.Context, in *WatchRipJobRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[RipUpdate], error)
	// Reap the job, deleting it from the in-memory cache.
	// This is meant to be called by the server after uploading relevant
	// details to the database.
	ReapJob(ctx context.Context, in *ReapJobRequest, opts ...grpc.CallOption) (*ReapJobResponse, error)
}

type driveControllerServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDriveControllerServiceClient(cc grpc.ClientConnInterface) DriveControllerServiceClient {
	return &driveControllerServiceClient{cc}
}

func (c *driveControllerServiceClient) GetDriveCount(ctx context.Context, in *GetDriveCountRequest, opts ...grpc.CallOption) (*GetDriveCountResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetDriveCountResponse)
	err := c.cc.Invoke(ctx, DriveControllerService_GetDriveCount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *driveControllerServiceClient) GetDriveMeta(ctx context.Context, in *GetDriveMetaRequest, opts ...grpc.CallOption) (*GetDriveMetaResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetDriveMetaResponse)
	err := c.cc.Invoke(ctx, DriveControllerService_GetDriveMeta_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *driveControllerServiceClient) Eject(ctx context.Context, in *EjectRequest, opts ...grpc.CallOption) (*EjectResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EjectResponse)
	err := c.cc.Invoke(ctx, DriveControllerService_Eject_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *driveControllerServiceClient) Retract(ctx context.Context, in *RetractRequest, opts ...grpc.CallOption) (*RetractResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RetractResponse)
	err := c.cc.Invoke(ctx, DriveControllerService_Retract_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *driveControllerServiceClient) GetDriveState(ctx context.Context, in *GetDriveStateRequest, opts ...grpc.CallOption) (*DriveState, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DriveState)
	err := c.cc.Invoke(ctx, DriveControllerService_GetDriveState_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *driveControllerServiceClient) RipMedia(ctx context.Context, in *RipMediaRequest, opts ...grpc.CallOption) (*RipMediaResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RipMediaResponse)
	err := c.cc.Invoke(ctx, DriveControllerService_RipMedia_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *driveControllerServiceClient) GetJobStatus(ctx context.Context, in *GetJobStatusRequest, opts ...grpc.CallOption) (*RipStatus, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RipStatus)
	err := c.cc.Invoke(ctx, DriveControllerService_GetJobStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *driveControllerServiceClient) WatchRipJob(ctx context.Context, in *WatchRipJobRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[RipUpdate], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &DriveControllerService_ServiceDesc.Streams[0], DriveControllerService_WatchRipJob_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[WatchRipJobRequest, RipUpdate]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type DriveControllerService_WatchRipJobClient = grpc.ServerStreamingClient[RipUpdate]

func (c *driveControllerServiceClient) ReapJob(ctx context.Context, in *ReapJobRequest, opts ...grpc.CallOption) (*ReapJobResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReapJobResponse)
	err := c.cc.Invoke(ctx, DriveControllerService_ReapJob_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DriveControllerServiceServer is the server API for DriveControllerService service.
// All implementations should embed UnimplementedDriveControllerServiceServer
// for forward compatibility.
type DriveControllerServiceServer interface {
	// Gets the number of drives registered with this controller.
	// Drive IDs are a contiguous sequence starting from 0, going up to
	// (but not including) the result of this function.
	GetDriveCount(context.Context, *GetDriveCountRequest) (*GetDriveCountResponse, error)
	// Get metadata about the drive
	GetDriveMeta(context.Context, *GetDriveMetaRequest) (*GetDriveMetaResponse, error)
	// Ejects the disc in the drive
	Eject(context.Context, *EjectRequest) (*EjectResponse, error)
	// Retracts the disc in the drive
	Retract(context.Context, *RetractRequest) (*RetractResponse, error)
	// Gets the current state of the drive
	GetDriveState(context.Context, *GetDriveStateRequest) (*DriveState, error)
	// Rips the media in the drive. Returns immediately. Status changes
	// come through the FollowRipJob stream.
	RipMedia(context.Context, *RipMediaRequest) (*RipMediaResponse, error)
	// Requests the current status of a job
	GetJobStatus(context.Context, *GetJobStatusRequest) (*RipStatus, error)
	// Creates a stream of RipUpdate responses, useful for monitoring the
	// real-time status of a job
	WatchRipJob(*WatchRipJobRequest, grpc.ServerStreamingServer[RipUpdate]) error
	// Reap the job, deleting it from the in-memory cache.
	// This is meant to be called by the server after uploading relevant
	// details to the database.
	ReapJob(context.Context, *ReapJobRequest) (*ReapJobResponse, error)
}

// UnimplementedDriveControllerServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedDriveControllerServiceServer struct{}

func (UnimplementedDriveControllerServiceServer) GetDriveCount(context.Context, *GetDriveCountRequest) (*GetDriveCountResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDriveCount not implemented")
}
func (UnimplementedDriveControllerServiceServer) GetDriveMeta(context.Context, *GetDriveMetaRequest) (*GetDriveMetaResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDriveMeta not implemented")
}
func (UnimplementedDriveControllerServiceServer) Eject(context.Context, *EjectRequest) (*EjectResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Eject not implemented")
}
func (UnimplementedDriveControllerServiceServer) Retract(context.Context, *RetractRequest) (*RetractResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Retract not implemented")
}
func (UnimplementedDriveControllerServiceServer) GetDriveState(context.Context, *GetDriveStateRequest) (*DriveState, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDriveState not implemented")
}
func (UnimplementedDriveControllerServiceServer) RipMedia(context.Context, *RipMediaRequest) (*RipMediaResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RipMedia not implemented")
}
func (UnimplementedDriveControllerServiceServer) GetJobStatus(context.Context, *GetJobStatusRequest) (*RipStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetJobStatus not implemented")
}
func (UnimplementedDriveControllerServiceServer) WatchRipJob(*WatchRipJobRequest, grpc.ServerStreamingServer[RipUpdate]) error {
	return status.Errorf(codes.Unimplemented, "method WatchRipJob not implemented")
}
func (UnimplementedDriveControllerServiceServer) ReapJob(context.Context, *ReapJobRequest) (*ReapJobResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReapJob not implemented")
}
func (UnimplementedDriveControllerServiceServer) testEmbeddedByValue() {}

// UnsafeDriveControllerServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DriveControllerServiceServer will
// result in compilation errors.
type UnsafeDriveControllerServiceServer interface {
	mustEmbedUnimplementedDriveControllerServiceServer()
}

func RegisterDriveControllerServiceServer(s grpc.ServiceRegistrar, srv DriveControllerServiceServer) {
	// If the following call pancis, it indicates UnimplementedDriveControllerServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&DriveControllerService_ServiceDesc, srv)
}

func _DriveControllerService_GetDriveCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDriveCountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DriveControllerServiceServer).GetDriveCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DriveControllerService_GetDriveCount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DriveControllerServiceServer).GetDriveCount(ctx, req.(*GetDriveCountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DriveControllerService_GetDriveMeta_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDriveMetaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DriveControllerServiceServer).GetDriveMeta(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DriveControllerService_GetDriveMeta_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DriveControllerServiceServer).GetDriveMeta(ctx, req.(*GetDriveMetaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DriveControllerService_Eject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DriveControllerServiceServer).Eject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DriveControllerService_Eject_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DriveControllerServiceServer).Eject(ctx, req.(*EjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DriveControllerService_Retract_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RetractRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DriveControllerServiceServer).Retract(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DriveControllerService_Retract_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DriveControllerServiceServer).Retract(ctx, req.(*RetractRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DriveControllerService_GetDriveState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDriveStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DriveControllerServiceServer).GetDriveState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DriveControllerService_GetDriveState_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DriveControllerServiceServer).GetDriveState(ctx, req.(*GetDriveStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DriveControllerService_RipMedia_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RipMediaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DriveControllerServiceServer).RipMedia(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DriveControllerService_RipMedia_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DriveControllerServiceServer).RipMedia(ctx, req.(*RipMediaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DriveControllerService_GetJobStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetJobStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DriveControllerServiceServer).GetJobStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DriveControllerService_GetJobStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DriveControllerServiceServer).GetJobStatus(ctx, req.(*GetJobStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DriveControllerService_WatchRipJob_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchRipJobRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DriveControllerServiceServer).WatchRipJob(m, &grpc.GenericServerStream[WatchRipJobRequest, RipUpdate]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type DriveControllerService_WatchRipJobServer = grpc.ServerStreamingServer[RipUpdate]

func _DriveControllerService_ReapJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReapJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DriveControllerServiceServer).ReapJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DriveControllerService_ReapJob_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DriveControllerServiceServer).ReapJob(ctx, req.(*ReapJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// DriveControllerService_ServiceDesc is the grpc.ServiceDesc for DriveControllerService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DriveControllerService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "mediacorral.drive_controller.v1.DriveControllerService",
	HandlerType: (*DriveControllerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetDriveCount",
			Handler:    _DriveControllerService_GetDriveCount_Handler,
		},
		{
			MethodName: "GetDriveMeta",
			Handler:    _DriveControllerService_GetDriveMeta_Handler,
		},
		{
			MethodName: "Eject",
			Handler:    _DriveControllerService_Eject_Handler,
		},
		{
			MethodName: "Retract",
			Handler:    _DriveControllerService_Retract_Handler,
		},
		{
			MethodName: "GetDriveState",
			Handler:    _DriveControllerService_GetDriveState_Handler,
		},
		{
			MethodName: "RipMedia",
			Handler:    _DriveControllerService_RipMedia_Handler,
		},
		{
			MethodName: "GetJobStatus",
			Handler:    _DriveControllerService_GetJobStatus_Handler,
		},
		{
			MethodName: "ReapJob",
			Handler:    _DriveControllerService_ReapJob_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WatchRipJob",
			Handler:       _DriveControllerService_WatchRipJob_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "mediacorral/drive_controller/v1/main.proto",
}
